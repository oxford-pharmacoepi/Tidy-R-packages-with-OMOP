[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Building tidy R packages for the OMOP common data model",
    "section": "",
    "text": "Preface\nThis is an opinionated book on how we develop packages working in the Tidy R OMOP CDM space.\nOur book, although covers some parts of basic R package development assumes the user knows the very basis. If you are new to R package development we would recommend you the following book: R Packages; Learn how to create a package, the fundamental unit of shareable, reusable, and reproducible R code.\nThe book is divided in four parts:\n\n(I) Getting started: covers how to start with an empty package, and helps you think about which is the scope of your package or guide you on how to contribute to existing packages.\n(II) Principles: this is the most important part of the book as it covers which packages to use, the different naming conventions, classes to use, how to validate the inputs and more.\n(III) Documentation: covers how to create the documentation of the packages, such as populate readme, documenting functions, documenting code, vignettes and more.\n(IV) Testing: covers how to write tests for the packages, what to test and how to do it efficiently.\n(V) GitHub: covers how to set up automatic GitHub testing and documentation using GitHub actions.\n(VI) Maintaining a package: once a package is ready for a first release you will have to maintain it, this packages covers how to submit to cran for first time and maintain the package for the future.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "getting_started/index.html",
    "href": "getting_started/index.html",
    "title": "Getting started",
    "section": "",
    "text": "In this first part it is covered how to …",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "getting_started/scope.html",
    "href": "getting_started/scope.html",
    "title": "1  Scope",
    "section": "",
    "text": "1.1 Is this package needed?\nBefore deciding to develop a package you must ask yourself many questions starting with: Is this package needed? A package must cover need and be refined.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "getting_started/ecosystem.html",
    "href": "getting_started/ecosystem.html",
    "title": "2  Ecosystem",
    "section": "",
    "text": "2.1 How the package fits in the ecosystem",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ecosystem</span>"
    ]
  },
  {
    "objectID": "getting_started/contributing.html",
    "href": "getting_started/contributing.html",
    "title": "3  Contributing to a package",
    "section": "",
    "text": "3.1 GitHub issues",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "getting_started/contributing.html#github-issues",
    "href": "getting_started/contributing.html#github-issues",
    "title": "3  Contributing to a package",
    "section": "",
    "text": "3.1.1 Opening GitHub issues\nThe first step to contributing to an existing package is by opening issues on its GitHub repository. These issues could be about bugs you encountered when using the package, requests for additional functionality (that you might even want to add yourself), or clarification questions on package documentation.\n\n\n3.1.2 What makes a good issue\nIf reporting a bug, then a reprex makes the maintainers life much, much easier (and in turn increases the likelihood of a quick fix being introduced much higher!). This reprex will allow the developer to quickly reproduce the issue. This is already halfway to solving it, given the old adage &gt; “A problem well stated is half solved.”\nOften an issue may arise when running code against a database with real patient-level data which can make it challenging to quickly create a reprex (as the patient data for which the bug was seen cannot be shared). In this situation it may be possible to reproduce the problem on an available synthetic dataset like Eunomia, in which case the package developer will be able to reproduce the bug with the synthetic data. However, it may be that you only encounter the issue for some particular set of patients with specific characteristics which are not seen in the synthetic data. In this case you can, for example, use the omock package to create a set of synthetic patients with these characteristics so that the developer can use this same data to reproduce the problem.\nAlthough of course it would be ideal to include a reprex, this may not always be possible. In such cases please do make sure to provide a bug report, with as much information as possible, as this will still be extremely useful and appreciated.\nIf opening an issue to ask for clarifications on documentation or with requests for additional functionality, the more precise and specific the issue the better. If you have a long laundry list of feature requests, it would generally be better to open each as separate issues so they can be addressed incrementally.\nNote, even if you are not the maintainer of package but want to open a pull request to change documentation or add functionality then try to always open an issue to discuss this first. Even some seemingly trivial changes might be out of scope for the package (or they might have already been added in development branches of the repo). However well-intentioned, “drive-by pull requests” are often challenging for package maintainers to deal with.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "getting_started/contributing.html#responding-to-github-issues",
    "href": "getting_started/contributing.html#responding-to-github-issues",
    "title": "3  Contributing to a package",
    "section": "3.2 Responding to GitHub issues",
    "text": "3.2 Responding to GitHub issues\nOn the other side of the equation if you are the maintainer of package, receiving issues is one the main ways you will receive feedback on the package. Get used to starting with somewhat vague issues that will need some back and forth to get to the route of the problem or request for additional functionality.\nWhen a bug is fixed in the package as a rule you should also add a corresponding test to make sure that it will stay fixed into the future. One benefit of being given a reprex is that not only will it help you to fix the problem but the reprex itself can be used as the test for the package. By receiving and acting on issues raised, which will often be somewhat exotic edge cases or people using the package in some way that you hadn’t expected, the package will become hardened over time.\nWhen it comes to requests for adding functionality, or even offers to add it, this is a tricky balancing act. Remember that you will be the one maintaining the package in the long-term. It is often the case that the quick addition of something seemingly useful can make a package more difficult to maintain or extend in the future. Typically it is worth waiting a day or two at least before agreeing to add something to a package so that you don’t rush into making an addition or change that you will later come to regret.\nAnother point to keep in mind when considering issues with requests for functionality is whether to add more general functionality than is being asked for. A well-intentioned user may be asking for something very specific to be added, but often underlying this request will be a broader need for more general functionality. This my tie in to other requests received, or may even need more discussion with users to better understand whether there is a broader need at play. general solutions\nRemember that sadly few people be opening issues with praise if they’ve used your package successfully. The majority of users will use the code you’ve written without a problem and likely without even realising how much work has gone into it. And the people that do open issues are providing an extemely valuable service that will lead to the software getting better and better over time. So try to keep this in mind when tackling the seemingly never-ending list of issues you’ll get if your software is being used.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "getting_started/contributing.html#contributing-code",
    "href": "getting_started/contributing.html#contributing-code",
    "title": "3  Contributing to a package",
    "section": "3.3 Contributing code",
    "text": "3.3 Contributing code\n\nContribute documentation\nContributing documentation is one of the best ways to improve a package. Fixing typos, adding clarifications, and even writing whole vignettes will almost always be highly welcomed by the maintainer and improve the experience of other users. You can find issues related to documentation searching for the label documentation. Also you can open an issue if you think that somethings is not documented properly and propose the maintainer to fix it yourself.\nYou can read more details on how the documentation of the packages is done in the relevant chapters.\n\n\nFixing a bug\nContributing code is a more involved task. Before starting, make sure you’ve at the very least interacted with the maintainer so that they will be in favour of the changes or additions you are planning. You can do that replying to the issue you want to fix. Apart from fixing the bug, make sure to add tests alongside code changes to show that it is truly fixed. When fixing a bug existing tests should typically be unchanged (unless there is an issue with the test itself). If you are having to change existing tests to fix a bug this is normally a sign that there might be some more profound issue and will likely need back and forth between you and the maintainer for this to be addressed.\n\n\nAdding new functionality\nIf adding functionality this again should be accompanied with tests to show that it adds the desired behaviour. Moreover, updates to package documentation, including changes or additions to vignettes might be needed. Expect back and forth with the package maintainer, as they might well have feedback on the implementation you propose.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "getting_started/contributing.html#opening-pull-requests",
    "href": "getting_started/contributing.html#opening-pull-requests",
    "title": "3  Contributing to a package",
    "section": "3.4 Opening pull requests",
    "text": "3.4 Opening pull requests\nChanges to packages should come via pull requests. Create a branch or a fork of the code, make your change, and open your pull request. If opening a pull request, more than anything try to create a pull request that will be easy for the package maintainer to review and merge. A pull request will be better for everyone involved when it addresses just one specific issue and affects less than 250 lines of code. One quick way to create complexity for the maintainer is to open a pull request that addresses multiple issues at the same time. Although this could be more efficient for the person opening the pull request, it often slows down the review by increasing the complexity of the review for the maintainer.\nBefore starting to contribute any code, first make sure the package tests are all passing. To do so after cloning run the following code:\n\ndevtools::check()\n\nThe output should be:\n\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\n\nIf not raise an issue before going any further (although please first make sure you have all the packages from imports and suggests installed).\nNow you are ready to do your code contribution. Add the relevant code and when you are happy with the changes that you have made, please follow these steps to open a pull request:\n\n3.4.1 Initial checks\nRun the below to update and check package documentation:\ndevtools::document()\ndevtools::check_man()\nTest that the examples work:\ndevtools::run_examples()\nTest that the readme and vignettes work and update the results if the output of any function has changed:\ndevtools::build_readme()\ndevtools::build_vignettes()\n\n\n3.4.2 Run tests\nAs you then contribute code, make sure that all the current tests and any you add continue to pass. All package tests can be run together with:\ndevtools::test()\nCode to add new functionality should be accompanied by tests. Code coverage can be checked using:\n# note, you may first have to detach the package\n# detach(\"package:IncidencePrevalence\", unload=TRUE)\ndevtools::test_coverage()\n\n\n3.4.3 Adhere to code style\nPlease adhere to the code style when adding any new code. Do not though restyle any code unrelated to your pull request as this will make code review more difficult.\nlintr::lint_package(linters = lintr::linters_with_defaults(\n  lintr::object_name_linter(styles = \"camelCase\")\n))\n\n\n3.4.4 Run check() before opening a pull request\nBefore opening any pull request please make sure to run:\ndevtools::check() \nPlease make sure that the output is the expected:\n\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\n\nAny error or warning will make your pull request actions fail. Although notes can pass the github action tests we encourage to fix all the notes as this is a requirement to keep the package on cran.\n\n\n3.4.5 Opening the pull request\nOnce you’ve made sure that checks are passing and you are happy with your code additions you can open the pull request. When opening the pull request you must take into account the following:\n\nWrite a meaningful title, titles of pull requests are later used to document the changes done. Make sure that the title of the pull request describes the issue that is fixed, therefore the documentation of the changes will be easier.\nLink the issue that your pull request is closing (we strongly encourage to fix issues one by one and do not include multiple issues in the same pull request). You can link a pull request and an issue using any of the gitub closing words or you can do it manually in the development section (bottom of the right sidebar).\nDescribe any potential issue you want to remark. Help the maintainer review your pull request indicating if there is anything you are not sure about or that you want some feedback on. Don’t hesitate to ask any question if needed.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "getting_started/contributing.html#reviewing-pull-requests",
    "href": "getting_started/contributing.html#reviewing-pull-requests",
    "title": "3  Contributing to a package",
    "section": "3.5 Reviewing pull requests",
    "text": "3.5 Reviewing pull requests\nReviewing pull requests is a very important step that the maintainers have to do. When reviewing a pull request you have to find a good equilibrium between being kind (we want to encourage people to contribute to our packages) and being strict (you -as a maintainer- will be the ultimate responsible for that code; so review it carefully and only accept if you are happy about it and you feel comfortable maintaining that code).",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html",
    "href": "getting_started/setup.html",
    "title": "4  Set up your environment",
    "section": "",
    "text": "4.1 Create an empty package\nTo build an R package you will need R installed and an IDE: preferably R Studio or Positron.\nYou will need to install devtools and usethis as they are key to follow the different steps to get started.\nTo work with the Tidy R OMOP ecosystem, you will also need to install the omopgenerics package. Alongside with other packages that may be useful:\nYou can see the list of Tidy R packages in our website.\nTo create an empty package you can do it with usethis:\nlibrary(usethis)\n\ncreate_package(path = \"path/to/folder\")",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#create-an-empty-package",
    "href": "getting_started/setup.html#create-an-empty-package",
    "title": "4  Set up your environment",
    "section": "",
    "text": "TipPackage name\n\n\n\n\n\nThe package will be named by the name of the folder.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#add-a-license",
    "href": "getting_started/setup.html#add-a-license",
    "title": "4  Set up your environment",
    "section": "4.2 Add a license",
    "text": "4.2 Add a license\nAdding licenses is very important so you are protected and users know how they can use your product. In general we release using the Apache 2.0 license.\nYou can add a license easily with usethis:\n\nuse_apl2_license()\n\nThis will add the LICENSE.md file and populate the DESCRIPTION file with the relevant license field.\n\n\n\n\n\n\nNoteLicense agreements\n\n\n\n\n\nLicense agreements supported by usethis are:\n\nMore permissive:\n\nMIT: simple and permissive.\nApache 2.0: MIT + provides patent protection.\n\nCopyleft:\n\nGPL v2: requires sharing of improvements.\nGPL v3: requires sharing of improvements.\nAGPL v3: requires sharing of improvements.\nLGPL v2.1: requires sharing of improvements.\nLGPL v3: requires sharing of improvements.\n\nCreative commons licenses appropriate for data packages:\n\nCC0: dedicated to public domain.\nCC-BY: Free to share and adapt, must give appropriate credit.\n\n\n\nuse_mit_license(copyright_holder = NULL)\n\nuse_gpl_license(version = 3, include_future = TRUE)\n\nuse_agpl_license(version = 3, include_future = TRUE)\n\nuse_lgpl_license(version = 3, include_future = TRUE)\n\nuse_apache_license(version = 2, include_future = TRUE)\n\nuse_cc0_license()\n\nuse_ccby_license()\n\nuse_proprietary_license(copyright_holder = \"...\")",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#create-a-first-mock-function",
    "href": "getting_started/setup.html#create-a-first-mock-function",
    "title": "4  Set up your environment",
    "section": "4.3 Create a first mock function",
    "text": "4.3 Create a first mock function\nThe R folder contains the relevant files for your package",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#check-the-package",
    "href": "getting_started/setup.html#check-the-package",
    "title": "4  Set up your environment",
    "section": "4.4 Check the package",
    "text": "4.4 Check the package",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#create-a-simple-test",
    "href": "getting_started/setup.html#create-a-simple-test",
    "title": "4  Set up your environment",
    "section": "4.5 Create a simple test",
    "text": "4.5 Create a simple test\nWe will see\nAfter adding the test we should check the test works properly. You can run the tests of the active file using:\n\ntest_active_file()\n\nOr you can run all the tests of the package:\n\ntest()",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#create-readme.rmd",
    "href": "getting_started/setup.html#create-readme.rmd",
    "title": "4  Set up your environment",
    "section": "4.6 Create README.Rmd",
    "text": "4.6 Create README.Rmd",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#create-website",
    "href": "getting_started/setup.html#create-website",
    "title": "4  Set up your environment",
    "section": "4.7 Create website",
    "text": "4.7 Create website",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#set-up-github",
    "href": "getting_started/setup.html#set-up-github",
    "title": "4  Set up your environment",
    "section": "4.8 Set up GitHub",
    "text": "4.8 Set up GitHub\nGitHub actions are very useful to ensure the continuous integration workflow. The fifth part of the book is dedicated to GitHub and GitHub Actions at that stage you will learn how to use github for:\n\nAutomatic checking your package\nAutomatic deployment of a documentation website for your package\nAutomatic assessment of test coverage\nAutomatic testing across multiple sources",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "getting_started/setup.html#package-template",
    "href": "getting_started/setup.html#package-template",
    "title": "4  Set up your environment",
    "section": "4.9 Package template",
    "text": "4.9 Package template\nAlthough the first time it is quite nice to do all the steps one by one there is a template with all those steps done, you can create a new package repo using this link.\n\n\n\n\n\n\nNoteTemplate link\n\n\n\n\n\nThe GitHub template link can be found: https://github.com/oxford-pharmacoepi/EmptyPackageTemplate.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Set up your environment</span>"
    ]
  },
  {
    "objectID": "principles/core_dependencies.html",
    "href": "principles/core_dependencies.html",
    "title": "5  Core dependencies",
    "section": "",
    "text": "5.1 omopgenerics\nThe Tidy R OMOP CDM packages rely on dplyr and the tidyverse packages to manipulate the data from the cdm object. The cdm object is an object that contains all the tables available and is central for the data manipulation. This cdm object is defined in omopgenerics.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Core dependencies</span>"
    ]
  },
  {
    "objectID": "principles/core_dependencies.html#omopgenerics",
    "href": "principles/core_dependencies.html#omopgenerics",
    "title": "5  Core dependencies",
    "section": "",
    "text": "5.1.1 Classes\n\n\n5.1.2 Methods\n\n\n5.1.3 Input validation functions\n\n\n5.1.4 Manipulate a cdm_reference object\n\n\n5.1.5 Manipulate a summarised_result object",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Core dependencies</span>"
    ]
  },
  {
    "objectID": "principles/core_dependencies.html#other-useful-packages",
    "href": "principles/core_dependencies.html#other-useful-packages",
    "title": "5  Core dependencies",
    "section": "5.2 Other useful packages",
    "text": "5.2 Other useful packages\nThe omopverse has some core packages that will be useful to simplify the scope of your package:\n\nPatientProfiles: this package is very useful for data manipulation, you can find extract basic demographic information, intersections of cohorts and summarise data in a standard format. Take a look at the list of functions in PatientProfiles to prevent you from duplicating code.\nvisOmopResults: this package is very useful to create data visualisations (tables and plots) from standardised data. There are many different supported types of tables (r visOmopResults::tableType()) and with little customisation you can get quite pretty tables. For plots the support is a bit more limited but it creates some simple ggplot2 visualisations with very little effort. Take a look at the list of functions in visOmopResults to prevent you from duplicating code.\nCodelistGenerator: this package can be useful to query the vocabularies. Take a look at the list of functions in CodelistGenerator to prevent you from duplicating code.\nomock: this package can be very useful for testing. With very few lines of code you can create a mock CDM object with your desired specifications, specially useful can be the function mockCdmFromTables() that will create a viable CDM object from the supplied information. Take a look at the list of functions in omock to prevent you from duplicating code. This package is quite useful, but usually listed in Suggests as you will only need this package for testing purposes.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Core dependencies</span>"
    ]
  },
  {
    "objectID": "principles/function_interfaces.html",
    "href": "principles/function_interfaces.html",
    "title": "6  Function interfaces",
    "section": "",
    "text": "generate...CohortSet, ...Cohort, add..., summarise..., plot..., table...,",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Function interfaces</span>"
    ]
  },
  {
    "objectID": "principles/conventions.html",
    "href": "principles/conventions.html",
    "title": "7  Conventions",
    "section": "",
    "text": "7.1 Casing\nOur code adheres to some style conventions as decribed in this chapter.\nIn general we use camelCase naming for arguments and functions.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Conventions</span>"
    ]
  },
  {
    "objectID": "principles/conventions.html#argument-naming",
    "href": "principles/conventions.html#argument-naming",
    "title": "7  Conventions",
    "section": "7.2 Argument naming",
    "text": "7.2 Argument naming",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Conventions</span>"
    ]
  },
  {
    "objectID": "principles/error_and_validation.html",
    "href": "principles/error_and_validation.html",
    "title": "8  Error messages and input validation",
    "section": "",
    "text": "8.1 omopgenerics validatin functions\nGiving users good and informative error messages is key for a good user experience. To do so it is important that we perform an input validation at the beginning of each function. On the other hand we do not want to spend more time checking the input than executing the function, so don’t overdo it. In general we would check that any input function has the desired type and length and that the desired evaluation looks feasible with the current input parameters.\nSome arguments that are consistent across different functions and packages have their own validate functions in the omopgenerics package:\nIt is important that we assign the output to the variable as the object might change during the validation process to ensure different allowed inputs but as the output of the validation process will always be the same this simplifys the code as you do not have to think about the different allowed inputs.\nthe ageGroup argument can be a good example of this behavior:\nlibrary(omopgenerics, warn.conflicts = FALSE)\nageGroup &lt;- validateAgeGroupArgument(ageGroup = list(c(0, 1), c(10, 20)))\nageGroup\n\n$age_group\n$age_group$`0 to 1`\n[1] 0 1\n\n$age_group$`10 to 20`\n[1] 10 20\n\nageGroup &lt;- validateAgeGroupArgument(ageGroup = list(\n  my_column = list(\"young\" = c(0, 19), 20, c(21, Inf)), \n  list(c(0, 9), c(10, 19), c(20, 29), c(30, Inf))\n))\nageGroup\n\n$my_column\n$my_column$young\n[1]  0 19\n\n$my_column$`20 to 20`\n[1] 20 20\n\n$my_column$`21 or above`\n[1]  21 Inf\n\n\n$age_group_2\n$age_group_2$`0 to 9`\n[1] 0 9\n\n$age_group_2$`10 to 19`\n[1] 10 19\n\n$age_group_2$`20 to 29`\n[1] 20 29\n\n$age_group_2$`30 or above`\n[1]  30 Inf\nAs you can see the output is always a named list that contains named intervals the function itself will also throw explanatory errors if they are not properly formatted:\nvalidateAgeGroupArgument(\n  ageGroup = list(age_group1 = list(c(0, 19), c(20, Inf)), age_group2 = list(c(0, Inf))),\n  multipleAgeGroup = FALSE\n)\n\nError:\n! Multiple age group are not allowed\n\nvalidateAgeGroupArgument(\n  ageGroup = list(age_group1 = list(c(-5, 19), c(20, Inf)))\n)\n\nError in `purrr::map()`:\nℹ In index: 1.\nℹ With name: age_group1.\nCaused by error:\n! Elements of `ageGroup` argument must be greater or equal to \"0\".\n\nvalidateAgeGroupArgument(\n  ageGroup = NULL, null = FALSE \n)\n\nError:\n! `ageGroup` argument can not be NULL.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Error messages and input validation</span>"
    ]
  },
  {
    "objectID": "principles/error_and_validation.html#omopgenerics-validatin-functions",
    "href": "principles/error_and_validation.html#omopgenerics-validatin-functions",
    "title": "8  Error messages and input validation",
    "section": "",
    "text": "validatevalidateAgeGroupArgument() is used to validate the ageGroup argument. The output ageGroup will always be formatted as a named list (name of the age group) and each age group will be defined by named intervals.\nvalidateCdmArgument() is used to validate the cdm argument. By default only the class is validated as this can take time, but specific checks can be triggered if needed.\nvalidateCohortArgument() is used to validate cohort argument, very used in many packages, this validates that the input is a properly formatted cohort. Extra checks can be triggered if needed.\nvalidateCohortIdArgument() is used to validate cohortId argument\nvalidateConceptSetArgument()\nvalidateNameArgument()\nvalidateNameStyle()\nvalidateResultArgument()\nvalidateStrataArgument()\nvalidateWindowArgument()",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Error messages and input validation</span>"
    ]
  },
  {
    "objectID": "principles/error_and_validation.html#omopgenerics-assert-functions",
    "href": "principles/error_and_validation.html#omopgenerics-assert-functions",
    "title": "8  Error messages and input validation",
    "section": "8.2 omopgenerics assert functions",
    "text": "8.2 omopgenerics assert functions\nThe omopgenerics package contains some functions for simple validation steps this can be useful helpers to validate an input with a single line of code, they also contain arguments to check if they have",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Error messages and input validation</span>"
    ]
  },
  {
    "objectID": "principles/error_and_validation.html#examples",
    "href": "principles/error_and_validation.html#examples",
    "title": "8  Error messages and input validation",
    "section": "8.3 Examples",
    "text": "8.3 Examples\nLet’s say we have a function with four arguments (cohort, cohortId, window and overlap), we could easily validate the input arguments of the function with 4 lines of code:\n\nmyFunction &lt;- function(cohort, cohortId = NULL, window = c(0, Inf), overlap = FALSE) {\n  # input check\n  cohort &lt;- omopgenerics::validateCohortArgument(cohort = cohort)\n  cohortId &lt;- omopgenerics::validateCohortIdArgument(cohortId = {{cohortId}}, cohort = cohort)\n  window &lt;- omopgenerics::validateWindowArgument(window = window)\n  omopgenerics::assertLogical(overlap, length = 1)\n  \n  # code ...\n  \n}\n\nNote the {{ symbols are needed to be able to use tidyselect verbs such as starts_with() or contains().\nA second example that needs some custom extra code can be:\n\nmyFunction &lt;- function(cdm, conceptSet, days = 180L, startDate = NULL, overlap = TRUE) {\n  # input check\n  cdm &lt;- omopgenerics::validateCdmArgument(cdm = cdm)\n  conceptSet &lt;- omopgenerics::validateCdmArgument(conceptSet = conceptSet)\n  omopgenerics::assertNumeric(days, integerish = TRUE, min = 0, length = 1)\n  omopgenerics::assertDate(startDate, length = 1, null = TRUE)\n  if (overlap & days &gt; 365) {\n    cli::cli_abort(c(x = \"{.var days} is can not be &gt;= 365 if {.var overlap} is TRUE.\"))\n  }\n\n  # code ...\n  \n}\n\nYou can throw custom error and warning messages using the cli package.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Error messages and input validation</span>"
    ]
  },
  {
    "objectID": "principles/error_and_validation.html#conclusions",
    "href": "principles/error_and_validation.html#conclusions",
    "title": "8  Error messages and input validation",
    "section": "8.4 Conclusions",
    "text": "8.4 Conclusions\nValidating arguments is a very important step to give user a good experience and prevent running undesired code in big datasets. The omopgenerics provides you with some functionality to keep the validation step short and consistent with other packages.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Error messages and input validation</span>"
    ]
  },
  {
    "objectID": "principles/function_outputs.html",
    "href": "principles/function_outputs.html",
    "title": "9  Function outputs",
    "section": "",
    "text": "9.1 The summarised_result object\nThe summarised_result object is an S3 class defined by omopgenerics that aims to standardise the result outputs that contain estimates.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Function outputs</span>"
    ]
  },
  {
    "objectID": "principles/function_outputs.html#the-summarised_result-object",
    "href": "principles/function_outputs.html#the-summarised_result-object",
    "title": "9  Function outputs",
    "section": "",
    "text": "9.1.1 The summarised_result basis\nThe summarised result is a tibble wi\n\nMain table\nSettings. Compulsory settings are:\n\nresult_type\npackage_name\npackage_version Other columns that are always created in settings:\ngroup, strata, additional\nmin_cell_count this column will always exists (it will be “0” by default).\n\n\nThe tidy format, a summarised result can easily be converted to a simpler table, you can use internally this format\n\n\n9.1.2 How to create a summarised result\nPlease include only one result_type this make it easy\n\nway to identify result_type\nunique result_type\ntransform to summarise result\ntidy\n\n\n\n9.1.3 Suppression\n\nmake sure that we include a number subjects if relevant\nuse the word count in estimates\n\n\n\n9.1.4 Register the result_type",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Function outputs</span>"
    ]
  },
  {
    "objectID": "principles/function_outputs.html#further-reading",
    "href": "principles/function_outputs.html#further-reading",
    "title": "9  Function outputs",
    "section": "9.2 Further reading",
    "text": "9.2 Further reading\n\nThe summarised result object omopgenerics.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Function outputs</span>"
    ]
  },
  {
    "objectID": "documentation/code.html",
    "href": "documentation/code.html",
    "title": "13  Documenting code",
    "section": "",
    "text": "13.1 When to document?\nDocumenting code it is also important, after some weeks we will probably remember why you added some lines of code or what was needed next. Adding notes for yourself or the rest of developers it is always a good idea.\nIn general not all the lines of code need to be documented, a very simple example can be:\ny &lt;- x + 1\nYou do not need a comment to know that the value of y is going to be x plus one unit. But maybe you need to document why you did that for example when we calculate duration it is end - start + 1 as we want to calculate the number of days (start and end are included) and not the difference (end - start). This might not be obvious at first glance and giving a clue to you in the future or any other developer will save you time:\n# end and start are included in duration, we want number of days not difference\nduration &lt;- end - start + 1",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Documenting code</span>"
    ]
  },
  {
    "objectID": "documentation/functions.html",
    "href": "documentation/functions.html",
    "title": "14  Documenting functions",
    "section": "",
    "text": "14.1 Title\nWe use the roxygen2 package for documenting our functions. Using this package will help us to write the .Rd files in the man directory which is what will be rendered when users call ?my_function or help(\"my_function\") and peruse a package website.\nAbove each exported function we’ll create a roxygen block, with lines starting with #'. The general structure is shown below and we’ll go through each in turn.\nWe want to provide a concise yet informative title for our function. The title should typically be written in sentence case but without any full stop at the end.\nIf we run help(package = \"mypackage\") we can see all the functions and their titles for a package. From this we can quickly see how informative our titles are.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documentation/functions.html#description",
    "href": "documentation/functions.html#description",
    "title": "14  Documenting functions",
    "section": "14.2 Description",
    "text": "14.2 Description\nEvery function should have a desription. This could be a sentence or two for a simple function, or multiple paragraphs for a more complex function. The description should summarise the purpose of the function and explain any internal assumptions or decisions made to implement it.\nWhen writing the description we can use markdown commands, for example to add bullet points, italics, etc. This will often help make longer desriptions more readable.\n\n14.2.1 lifecycle badges",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documentation/functions.html#parameters",
    "href": "documentation/functions.html#parameters",
    "title": "14  Documenting functions",
    "section": "14.3 Parameters",
    "text": "14.3 Parameters\nAfter our description of the function as a whole, we will then describe each of the inputs to the function. In general we should be able to describe an argument in a few sentences. We should use them to tell the user what is allowed as an input and then what the input will be used for.\nIf we’re working on a package where we have multiple arguments with the same argument we can document arguments just once. We can create a helper like below for parameter x.\n\n#' Helper for consistent documentation of `x`.\n#'\n#' @param x \n#'\n#' @name xDoc\n#' @keywords internal\n\nWe can then reuse this documentation across the package by using @inheritParams\n\n#' Title\n#' \n#' @description\n#'\n#' @inheritParams xDoc\n#' @param y \n#'\n#' @returns \n#' @export\n#'\n#' @examples",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documentation/functions.html#returns",
    "href": "documentation/functions.html#returns",
    "title": "14  Documenting functions",
    "section": "14.4 Returns",
    "text": "14.4 Returns\nWe must also document what the function will return. For example, we can tell a user that our function will return a tibble with a certain set of columns. If our function has side-effects then we chould also document these.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documentation/functions.html#export",
    "href": "documentation/functions.html#export",
    "title": "14  Documenting functions",
    "section": "14.5 Export",
    "text": "14.5 Export\nBy including the @export tag our documentation will be generated as an .Rd file and users will see it in the package website, etc. If instead we want to document an internal function then we can replace this with @noRd.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documentation/functions.html#examples",
    "href": "documentation/functions.html#examples",
    "title": "14  Documenting functions",
    "section": "14.6 Examples",
    "text": "14.6 Examples\nLast but by no means least are a set of examples where we provide R code that shows how the function can be used in practice. These examples are quite possible the most important piece of documentation, as it is many users will look at these before reading any of the above.\nTypically we should try to give a number of informative examples that show users how the function can be used and provides some intuition on the impact of different arguments.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documentation/readme.html",
    "href": "documentation/readme.html",
    "title": "15  README",
    "section": "",
    "text": "15.1 Create the .Rmd file\nThe README.md is a very important part of an R package. It is probably the first thing the users will read once they decide to try out our package. The README must contain the goal of the package and clear examples so users can start using the package. Now we will so how to create it and how to populate it.\nIn general we will populate our README.md using a rmarkdown file (README.Rmd) if you don’t have it created you can create it with:\nlibrary(usethis)\nuse_readme_rmd()\nthis will create the README.Rmd file that generates the README.md. To later build the README.md you can use the following command:\nlibrary(devtools)\nbuild_readme()\nIf you are new to rmakdown probable this introduction will be useful: Introduction to R Markdown.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>README</span>"
    ]
  },
  {
    "objectID": "documentation/readme.html#create-the-.rmd-file",
    "href": "documentation/readme.html#create-the-.rmd-file",
    "title": "15  README",
    "section": "",
    "text": "NoteREADME.md and README.Rmd\n\n\n\n\n\nNote that for cran/website/github only the README.md exists, so any change that you do to the README.Rmd file wont affect the ‘real’ README.md file till you build it. Make sure to build the .md file every time that you modify the .Rmd.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>README</span>"
    ]
  },
  {
    "objectID": "documentation/readme.html#content",
    "href": "documentation/readme.html#content",
    "title": "15  README",
    "section": "15.2 Content",
    "text": "15.2 Content\nA good README.md file must contain the following sections:\n\n15.2.1 Badges\nBadges are quite useful to display at the top of your README, they contain information of the package in a synthetic and consistent way. The badges are generated from usethis functions. You will have to manually copy the badge that will be printed in the console in the desired README section, usually at the top:\n&lt;!-- badges: start --&gt;\nPASTE BADGES HERE\n&lt;!-- badges: end --&gt;\nlifecycle status The development status badge can provide the user the development status of the package. We would usually use “experimental” for packages still under development (usually version &lt; 1.0.0) and “stable” for stable packages, note if you add the stable badge this sets some expectations about the package like backwards compatibility. A lifecycle badge is highly recommended.\n\nuse_lifecycle_badge(\"experimental\")\nuse_lifecycle_badge(\"stable\")\n\ncran version The cran badge informs about the current version in cran (if submitted to cran). This badge is also highly recommended (even before submitting to cran).\n\nuse_cran_badge()\n\nbuild status The badge indicates if the last checks ran in your package passed or not. This badge should also be green otherwise this means the continuous integration is broken. If at some point actions break in main, fix it as soon as possible. This badge is also highly recommended. The badge is generated when GitHub Actions are set.\n[![Build Status](https://github.com/{user/organisation}/{package_name}/workflows/R-CMD-check/badge.svg)](https://github.com/{user/organisation}/{package_name}/actions?query=workflow%3AR-CMD-check)\ntest coverage\ncran downloads\n\n\n15.2.2 Tested sources\nIf your packages is designed to work with different cdm sources (e.g. duckdb, local, postgres, sql server, …) we would encourage you to include the different sources you actively test against. We will later see the Testing multiple DBMS chapter where we explain how to do this automatically using GitHub actions. A good display to show the tested sources would be:\n\n| Source | Driver | CDM reference | Status |\n|------------------|------------------|------------------|------------------|\n| Local R dataframe | N/A | `omopgenerics::cdmFromTables()` | [![](https://github.com/OHDSI/CohortConstructor/actions/workflows/test-local-omopgenerics.yaml/badge.svg?branch=main)](https://github.com/OHDSI/CohortConstructor/actions/workflows/test-local-omopgenerics.yaml) |\n| In-memory duckdb datatabase | duckdb | `CDMConnector::cdmFromCon()` | [![](https://github.com/OHDSI/CohortConstructor/actions/workflows/test-duckdb-CDMConnector.yaml/badge.svg?branch=main)](https://github.com/OHDSI/CohortConstructor/actions/workflows/test-duckdb-CDMConnector.yaml) |\n| Postgres database | RPostgres | `CDMConnector::cdmFromCon()` |  |\n| Postgres database | DatabaseConnector | `CDMConnector::cdmFromCon()` |  |\n| SQL Server database | odbc | `CDMConnector::cdmFromCon()` |  |\n| SQL Server database | DatabaseConnector | `CDMConnector::cdmFromCon()` |  |\n\n\n\n15.2.3 Goal of your package\nClearly state the goal of your package, do not extend much, usually 2/3 sentences are enough to describe what your package does.\n\n\n15.2.4 How to install\nMake sure to include information on how to install the package the current release from cran and the development version from GitHub. this section would usually look like:\n# Installation\n\n{pakage_name} can be installed from CRAN:\n\n  ```r\n  install.packages(\"{pakage_name}\")\nor\nlibrary(pak)\npkg_install(\"{pakage_name}\")\nIf you prefere to use pak.\nThe development version can be installed from GitHub:\nlibrary(pak)\npkg_install(\"{user/organisation}/{package_name}\")\n```\n\n\n15.2.5 Simple examples\nThis is the most important section. Catch user attention, show how your package can solve a problem they have. Usually try to include visualisations (like ‘flextable’ or ‘ggplot2’). If you have a table* function that depends on visOmopResults please use type = \"flextable\" in the README as it is better displayed than ‘gt’.\nWe also recommend to include diagrams on how some functions relate or how your package works. Spend some time on this section, remember that’s the first thing they will read about your package.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>README</span>"
    ]
  },
  {
    "objectID": "documentation/readme.html#example",
    "href": "documentation/readme.html#example",
    "title": "15  README",
    "section": "15.3 Example",
    "text": "15.3 Example\nHere we created a simple example of how a good README would look like:",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>README</span>"
    ]
  },
  {
    "objectID": "testing/index.html",
    "href": "testing/index.html",
    "title": "Testing",
    "section": "",
    "text": "Testing is a crucial part of R package development. Well-designed tests ensure that each function behaves as intended, protect the package from unexpected breakage when new features are added (new contributions should not cause existing tests to fail), and provide confidence when refactoring code (improving internal logic for efficiency should not alter the expected outputs). A comprehensive test suite also lowers the barrier for contributors: by making expected behaviour explicit, it becomes easier for others to understand how functions should work and to spot unintended changes.\nThis part of the book introduces good testing practices in the context of OMOP-based package development. It is organised into three chapters:\n\nIntroduction to testing provides a high-level overview of testing in R using modern tools and conventions. This chapter summarises the key concepts presented in the Testing section of R Packages by Wickham and Bryan (https://r-pkgs.org/testing-basics.html).\nTesting in OMOP describes approaches for testing packages that interact with the OMOP CDM instances. In particular, it introduces the use of the omock R package [CITE], which enables the creation of synthetic OMOP data to validate package functionality without relying on a live database.\nTesting against multiple DBMS explains how to configure your package to run tests across multiple database management systems that host an OMOP CDM, ensuring that your code behaves consistently and reliably across different environments.",
    "crumbs": [
      "Testing"
    ]
  },
  {
    "objectID": "testing/introduction.html",
    "href": "testing/introduction.html",
    "title": "18  Introduction to testing",
    "section": "",
    "text": "18.1 The Basics\nTesting is a fundamental part of developing reliable, maintainable R packages. A good test suite provides confidence that your functions behave as expected, prevents regressions when the code evolves, and acts as a form of living documentation of your package’s intended behaviour. This chapter introduces the core ideas of testing in R, following tidyverse practices. It focuses on practical techniques you will use in every package: setting up tests, writing expectations, organising helpers and fixtures, deciding what to test, and documenting your tests clearly.\nR’s testing ecosystem centres around the testthat package, supported by usethis for structuring test infrastructure and devtools for running tests during development. Together, these tools provide a simple and consistent workflow.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/introduction.html#the-basics",
    "href": "testing/introduction.html#the-basics",
    "title": "18  Introduction to testing",
    "section": "",
    "text": "18.1.1 Setting up test infrastructure\nThe first step is to enable testing for your package:\n\nlibrary(usethis)\nuse_testthat()\n\nThis command:\n\nadds testthat to your package’s Suggests\ncreates a top-level file tests/testthat.R\ncreates the directory tests/testthat/ where test files will live\n\n\n\n\n\n\n\nNoteParallel testing\n\n\n\n\n\nTests are run sequentially in alphabetical order of the files, but you can run those tests in parallel if you specify it:\n\nuse_testthat(parallel = TRUE)\n\nNote that by default tests will be ran in 2 runners, but you can increase that number setting an environment variable TESTTHAT_CPUS, see: https://testthat.r-lib.org/articles/parallel.html.\n\n\n\nTo create a new test file, use:\n\nuse_test(\"my_function\")\n\nThis creates tests/testthat/test-my_function.R, a template ready for adding tests.\n\n\n18.1.2 Writing test blocks\nTests are written inside test_that() blocks:\n\ntest_that(\"my_function adds numbers correctly\", {\n  expect_equal(my_function(1, 2), 3)\n})\n\nA good test block:\n\nhas a clear, descriptive name\nfocuses on one coherent behaviour\nkeeps heavy computation or complex setup outside the block\n\n\n\n18.1.3 Running tests\nDuring development, run your tests using:\n\nlibrary(devtools)\ntest()\n\nNote all tests also run automatically during R CMD check (check()).\nTests will be run against the current loaded functions, so make sure that you run load_all() to load the current/latest version of your package.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/introduction.html#expectations",
    "href": "testing/introduction.html#expectations",
    "title": "18  Introduction to testing",
    "section": "18.2 Expectations",
    "text": "18.2 Expectations\nExpectations are the core of every test. They express the conditions that must be true for a function to behave correctly. If an expectation fails, testthat produces an informative message.\n\n18.2.1 Common expectations\nFrequently used expectations include:\n\nexpect_equal(x, y): checks that objects are equal (with tolerance)\nexpect_identical(x, y): strict equality including type and attributes\nexpect_true(x) / expect_false(x): checks logical conditions\nexpect_error(expr) / expect_warning(expr) / expect_message(expr): checks for specific conditions produced by code\nexpect_s3_class(x, \"class\"): checks object class\nexpect_type(x, \"double\"): checks base type\n\n\n\n18.2.2 Why expectations matter\nExpectations define the expected behaviour of your functions. They make assumptions explicit, illustrate expected output, and help maintainers understand the code. They also provide protection against regressions when internal implementations change.\nA single test_that() block may contain several expectations, as long as they relate to the same behaviour.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/introduction.html#setup-and-helper-functions",
    "href": "testing/introduction.html#setup-and-helper-functions",
    "title": "18  Introduction to testing",
    "section": "18.3 Setup and Helper Functions",
    "text": "18.3 Setup and Helper Functions\nAs your test suite grows, repeated patterns often emerge: constructing similar inputs, generating mock data, or creating temporary environments. To keep tests clear and maintainable, testthat provides a structured approach for managing shared setup code.\n\n18.3.1 Helper files\nReusable functions should be placed in helper files. Any file named:\ntests/testthat/helper-*.R\nis executed before the tests run. These files are ideal for:\n\nmock datasets\nutility functions\nshared configuration\nfrequently used objects\n\nExample helper:\n\n# tests/testthat/helper-data.R\nmake_mock_patient &lt;- function(id = 1, gender = \"M\") {\n  tibble::tibble(person_id = id, gender_concept_id = gender)\n}\n\nTests can then use:\n\npatient &lt;- make_mock_patient()\n\n\n\n18.3.2 Setup and teardown\nFor more complex requirements, testthat supports setup and teardown files:\n\nsetup-*.R — executed before tests\nteardown-*.R — executed after tests\n\nThis pattern is useful to set up reusable mocks, database connections and so. We will see how to use those files in the Testing against multiple DBMS chapter to tests your package against multiple database management systems.\n\n\n18.3.3 Avoid top-level code\nYou should avoid running code at the top level of test files. Instead, place code inside helpers or test_that() blocks. This makes tests more predictable and prevents shared state from leaking between tests.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/introduction.html#what-to-test",
    "href": "testing/introduction.html#what-to-test",
    "title": "18  Introduction to testing",
    "section": "18.4 What to Test",
    "text": "18.4 What to Test\nGood tests focus on what your package promises to do. Tests should be scoped to the behaviour that your package is responsible for—not on implementation details or on the behaviour of external code.\n\n18.4.1 General guidelines\nYou should test:\n\nUsual cases: typical inputs your users will provide\nEdge cases: empty inputs, missing values, not usual combinations…\nError behaviour: invalid inputs should produce informative errors\nOutput structure: class, column names, attributes, lengths\nRegression tests: when a bug is fixed, add a test preventing its return, this is a very important step in test development so we do not encounter the same error once again.\n\n\n\n\n\n\n\nNoteScope tests to your own code\n\n\n\n\n\nAvoid testing behaviour of other packages, we want to check that our package not the other packages.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/introduction.html#documenting-tests",
    "href": "testing/introduction.html#documenting-tests",
    "title": "18  Introduction to testing",
    "section": "18.5 Documenting Tests",
    "text": "18.5 Documenting Tests\nTests should be readable and easy to understand. A well-written test suite functions as documentation for your package’s expected behaviour.\n\n18.5.1 Descriptive test names\nThe description passed to test_that() should be clear:\n\ntest_that(\"addAge correctly add age to a table\", {\n  ...\n})\n\nThis helps identify failures and understand the intention behind the test.\n\n\n18.5.2 Commenting test logic\nUse comments to clarify:\n\nwhy specific inputs were chosen\nwhy an output is expected\nwhat bug a test prevents from reappearing (e.g. you can refer the issue where the problem was reported)\nkey assumptions behind the test\n\nExample:\n\n# Missing values should be ignored; this mirrors the documented default.\nexpect_equal(mean_custom(c(1, 2, NA)), 1.5)\n\n\n\n18.5.3 Keeping tests readable\nTo maintain readability:\n\nkeep tests small and focused\navoid deep nesting\nuse helper functions for repeated patterns\nkeep example datasets small and simple (we will see how to create mock OMOP CDM datasets in the Testing in the OMOP CDM chapter)\n\nReadable tests make collaboration easier and reduce maintenance effort.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/introduction.html#test-coverage",
    "href": "testing/introduction.html#test-coverage",
    "title": "18  Introduction to testing",
    "section": "18.6 Test Coverage",
    "text": "18.6 Test Coverage\nTest coverage measures the proportion of your package’s code that is executed during testing. It is expressed as the percentage of lines inside your R/ folder that are run by the tests in tests/testthat/.\nYou can compute test coverage using:\n\ntest_coverage()\n\nThis generates an interactive report in the Viewer panel showing how many times each line of code was executed during testing, which lines are covered by tests, and, therefore, which lines remain untested.\nHigh test coverage increases confidence that your functions behave as expected across typical and edge-case scenarios. While achieving 100% coverage is ideal, it is not always practical; deprecated code paths or some edge-case checks may be difficult to test directly.\nAs a rule of thumb aim for at least 90%-95% coverage, in general, try to test all core logic, leaving only truly unavoidable lines uncovered.\nCoverage is not a substitute for thoughtful testing, but it is a valuable tool for identifying weak spots in your test suite and ensuring your package remains reliable as it evolves. At the end having a 100% test does not ensures that your package does what you want, it just ensures that it does not break. So think carefully your tests and test the core functionality.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/introduction.html#testing-on-cran",
    "href": "testing/introduction.html#testing-on-cran",
    "title": "18  Introduction to testing",
    "section": "18.7 Testing on CRAN",
    "text": "18.7 Testing on CRAN\nWhen submitting a package to CRAN the package is checked (like check() function does), all tests, examples, vignettes, and documentation must finish within 10 minutes of CPU time. Test can consume a substantial portion of this time limit, and it may exceed CRAN’s limits.\nTo keep your CRAN checks within the allowed time while still maintaining a comprehensive local tests, you can selectively skip the most expensive tests on CRAN using skip_on_cran():\ntest_that(“Test mean_custom behaviour”, { skip_on_cran() # Missing values should be ignored; this mirrors the documented default. expect_equal(mean_custom(c(1, 2, NA)), 1.5) }) ````\nThis approach allows you to run full tests locally and in continuous integration (e.g., GitHub Actions), but omit heavy or slow tests during CRAN checks, ensuring that only core functionality is tested on CRAN, while edge cases, performance tests, and large data scenarios are tested elsewhere.\n\n\n\n\n\n\nNoteSkip functions\n\n\n\n\n\nThe testthat package provides several functions for conditionally skipping tests.\nCommon examples include:\n\nskip_on_cran(): skip tests on CRAN only.\nskip_if(): skip based on a custom condition (e.g. skip_if(dbToTest == \"Postgres\")).\nskip_if_not_installed(): skip if a required package is missing (e.g. skip_if_not_installed(\"dplyr\")).\n\nSee the full list of skip helpers at: https://testthat.r-lib.org/reference/skip.html.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/introduction.html#further-reading",
    "href": "testing/introduction.html#further-reading",
    "title": "18  Introduction to testing",
    "section": "18.8 Further reading",
    "text": "18.8 Further reading\n\nWickham, H., & Bryan, J. R Packages (2nd ed.): Testing basics (Chapter 13). Available online at: https://r-pkgs.org/testing-basics.html\nWickham, H., & Bryan, J. R Packages (2nd ed.): Designing your test suite (Chapter 14). Available online at: https://r-pkgs.org/testing-design.html\nWickham, H., & Bryan, J. R Packages (2nd ed.): Advanced testing techniques (Chapter 15). Available online at: https://r-pkgs.org/testing-advanced.html",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Introduction to testing</span>"
    ]
  },
  {
    "objectID": "testing/test_omop.html",
    "href": "testing/test_omop.html",
    "title": "19  Testing in the OMOP CDM",
    "section": "",
    "text": "19.1 Using omock to create mock synthetic data\nIn this chapter we cover how to create synthetic data in the OMOP CDM format using the omock R package.",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Testing in the OMOP CDM</span>"
    ]
  },
  {
    "objectID": "testing/test_omop.html#using-omock-to-create-mock-synthetic-data",
    "href": "testing/test_omop.html#using-omock-to-create-mock-synthetic-data",
    "title": "19  Testing in the OMOP CDM",
    "section": "",
    "text": "19.1.1 Mock data\nYou can create simple mock datasets using the different mock functions in omock, we will create the dataset in\n\nomock::mock functions\n\n\n\n19.1.2 Mock datasets\nThe omock package also contains pre-build syntehtic datasets from Eunomia package. To use eunomia\n\nomock::mockCdmFromDataset\n\n\n\n19.1.3 Minimum viable dataset\n\nomock::mockCdmFromTables",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Testing in the OMOP CDM</span>"
    ]
  },
  {
    "objectID": "testing/test_omop.html#inserting-the-mock",
    "href": "testing/test_omop.html#inserting-the-mock",
    "title": "19  Testing in the OMOP CDM",
    "section": "19.2 Inserting the mock",
    "text": "19.2 Inserting the mock\nAll those functions create local",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Testing in the OMOP CDM</span>"
    ]
  },
  {
    "objectID": "testing/test_omop.html#reusing-mock-data",
    "href": "testing/test_omop.html#reusing-mock-data",
    "title": "19  Testing in the OMOP CDM",
    "section": "19.3 Reusing mock data",
    "text": "19.3 Reusing mock data",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Testing in the OMOP CDM</span>"
    ]
  },
  {
    "objectID": "testing/test_omop.html#further-reading",
    "href": "testing/test_omop.html#further-reading",
    "title": "19  Testing in the OMOP CDM",
    "section": "19.4 Further reading",
    "text": "19.4 Further reading\n\nomock paper\nomock package",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Testing in the OMOP CDM</span>"
    ]
  },
  {
    "objectID": "testing/test_dbms.html",
    "href": "testing/test_dbms.html",
    "title": "20  Testing against multiple DBMS",
    "section": "",
    "text": "In this chapter we c",
    "crumbs": [
      "Testing",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing against multiple DBMS</span>"
    ]
  },
  {
    "objectID": "maintainance/releasing.html",
    "href": "maintainance/releasing.html",
    "title": "26  Submit to CRAN",
    "section": "",
    "text": "What version to release (major, minor or patch)\nForced releases by cran\nnews\nreverse dependency",
    "crumbs": [
      "Maintaing a package",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Submit to CRAN</span>"
    ]
  }
]