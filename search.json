[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Building tidy R packages for the OMOP common data model",
    "section": "",
    "text": "Introduction\nThis is an opinionated book on how we develop packages in the omopverse.\nR packages\nFor general R package development we recommend the following book: R Packages; Learn how to create a package, the fundamental unit of shareable, reusable, and reproducible R code.\nThe book is divided in four parts:\n\nPart one: covers the main …\nPart two: covers the main …\nPart three: covers the main …\nPart four: covers the main …\nPart five: covers the main …\nBefore developing the package\n\nscope\nhow it fits within the ecosystem\n\nclasses (they are deffined in omopgenerics)\nerror messages\n\nWhy?\nHow?\n\nnaming\n\nfunctions\nstrcutures: generate...CohortSet, ...Cohort, add..., summarise..., plot..., table...,\narguments\n\ninput validation\ntesting\nreexport\nmain branch should be protected",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "gettingstarted.html",
    "href": "gettingstarted.html",
    "title": "Getting started",
    "section": "",
    "text": "To build an R package you will need R installed and an IDE: preferably R Studio or Positron.\nThere are some packages that you will need devtools and usethis they are key to follow the different steps on this package building tutorial.\n\ninstall.packages(\"pak\")\nlibrary(pak)\npkg_install(\"usethis\")\npkg_install(\"devtools\")\n\nTo work with the omopverse, you will also need to install the omopgenerics package. Alongside with other packages that may be useful:\n\nPatientProfiles for data manipulation.\nCodelistDiagnostics to query the vocabularies.\nvisOmopResults for data visualisation.\n\nYou can see the list of the omopverse packages in our website.",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "conventions.html",
    "href": "conventions.html",
    "title": "3  Conventions",
    "section": "",
    "text": "3.1 Casing\nOur code adheres to some style conventions as decribed in this chapter.\nIn general we use camelCase naming for arguments and functions.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conventions</span>"
    ]
  },
  {
    "objectID": "contributing.html",
    "href": "contributing.html",
    "title": "5  Contributing to a package",
    "section": "",
    "text": "5.1 GitHub issues",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "contributing.html#github-issues",
    "href": "contributing.html#github-issues",
    "title": "5  Contributing to a package",
    "section": "",
    "text": "5.1.1 Opening GitHub issues\nThe first step to contributing to an existing package is by opening issues on its GitHub repository. These issues could be about bugs you encountered when using the package, requests for additional functionality (that you might even want to add yourself), or clarification questions on package documentation.\n\n\n5.1.2 What makes a good issue\nIf reporting a bug, then a reprex makes the maintainers life much, much easier (and in turn increases the likelihood of a quick fix being introduced much higher!). This reprex will allow the developer to quickly reproduce the issue. This is already halfway to solving it, given the old adage &gt; “A problem well stated is half solved.”\nOften an issue may arise when running code against a database with real patient-level data which can make it challenging to quickly create a reprex (as the patient data for which the bug was seen cannot be shared). In this situation it may be possible to reproduce the problem on an available synthetic dataset like Eunomia, in which case the package developer will be able to reproduce the bug with the synthetic data. However, it may be that you only encounter the issue for some particular set of patients with specific characteristics which are not seen in the synthetic data. In this case you can, for example, use the omock package to create a set of synthetic patients with these characteristics so that the developer can use this same data to reproduce the problem.\nAlthough of course it would be ideal to include a reprex, this may not always be possible. In such cases please do make sure to provide a bug report, with as much information as possible, as this will still be extremely useful and appreciated.\nIf opening an issue to ask for clarifications on documentation or with requests for additional functionality, the more precise and specific the issue the better. If you have a long laundry list of feature requests, it would generally be better to open each as separate issues so they can be addressed incrementally.\nNote, even if you are not the maintainer of package but want to open a pull request to change documentation or add functionality then try to always open an issue to discuss this first. Even some seemingly trivial changes might be out of scope for the package (or they might have already been added in development branches of the repo). However well-intentioned, “drive-by pull requests” are often challenging for package maintainers to deal with.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "contributing.html#responding-to-github-issues",
    "href": "contributing.html#responding-to-github-issues",
    "title": "5  Contributing to a package",
    "section": "5.2 Responding to GitHub issues",
    "text": "5.2 Responding to GitHub issues\nOn the other side of the equation if you are the maintainer of package, receiving issues is one the main ways you will receive feedback on the package. Get used to starting with somewhat vague issues that will need some back and forth to get to the route of the problem or request for additional functionality.\nWhen a bug is fixed in the package as a rule you should also add a corresponding test to make sure that it will stay fixed into the future. One benefit of being given a reprex is that not only will it help you to fix the problem but the reprex itself can be used as the test for the package. By receiving and acting on issues raised, which will often be somewhat exotic edge cases or people using the package in some way that you hadn’t expected, the package will become hardened over time.\nWhen it comes to requests for adding functionality, or even offers to add it, this is a tricky balancing act. Remember that you will be the one maintaining the package in the long-term. It is often the case that the quick addition of something seemingly useful can make a package more difficult to maintain or extend in the future. Typically it is worth waiting a day or two at least before agreeing to add something to a package so that you don’t rush into making an addition or change that you will later come to regret.\nAnother point to keep in mind when considering issues with requests for functionality is whether to add more general functionality than is being asked for. A well-intentioned user may be asking for something very specific to be added, but often underlying this request will be a broader need for more general functionality. This my tie in to other requests received, or may even need more discussion with users to better understand whether there is a broader need at play. general solutions\nRemember that sadly few people be opening issues with praise if they’ve used your package successfully. The majority of users will use the code you’ve written without a problem and likely without even realising how much work has gone into it. And the people that do open issues are providing an extemely valuable service that will lead to the software getting better and better over time. So try to keep this in mind when tackling the seemingly never-ending list of issues you’ll get if your software is being used.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "contributing.html#contributing-code",
    "href": "contributing.html#contributing-code",
    "title": "5  Contributing to a package",
    "section": "5.3 Contributing code",
    "text": "5.3 Contributing code\n\nContribute documentation\nContributing documentation is one of the best ways to improve a package. Fixing typos, adding clarifications, and even writing whole vignettes will almost always be highly welcomed by the maintainer and improve the experience of other users. You can find issues related to documentation searching for the label documentation. Also you can open an issue if you think that somethings is not documented properly and propose the maintainer to fix it yourself.\nYou can read more details on how the documentation of the packages is done in the relevant chapters.\n\n\nFixing a bug\nContributing code is a more involved task. Before starting, make sure you’ve at the very least interacted with the maintainer so that they will be in favour of the changes or additions you are planning. You can do that replying to the issue you want to fix. Apart from fixing the bug, make sure to add tests alongside code changes to show that it is truly fixed. When fixing a bug existing tests should typically be unchanged (unless there is an issue with the test itself). If you are having to change existing tests to fix a bug this is normally a sign that there might be some more profound issue and will likely need back and forth between you and the maintainer for this to be addressed.\n\n\nAdding new functionality\nIf adding functionality this again should be accompanied with tests to show that it adds the desired behaviour. Moreover, updates to package documentation, including changes or additions to vignettes might be needed. Expect back and forth with the package maintainer, as they might well have feedback on the implementation you propose.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "contributing.html#opening-pull-requests",
    "href": "contributing.html#opening-pull-requests",
    "title": "5  Contributing to a package",
    "section": "5.4 Opening pull requests",
    "text": "5.4 Opening pull requests\nChanges to packages should come via pull requests. Create a branch or a fork of the code, make your change, and open your pull request. If opening a pull request, more than anything try to create a pull request that will be easy for the package maintainer to review and merge. A pull request will be better for everyone involved when it addresses just one specific issue and affects less than 250 lines of code. One quick way to create complexity for the maintainer is to open a pull request that addresses multiple issues at the same time. Although this could be more efficient for the person opening the pull request, it often slows down the review by increasing the complexity of the review for the maintainer.\nBefore starting to contribute any code, first make sure the package tests are all passing. To do so after cloning run the following code:\n\ndevtools::check()\n\nThe output should be:\n\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\n\nIf not raise an issue before going any further (although please first make sure you have all the packages from imports and suggests installed).\nNow you are ready to do your code contribution. Add the relevant code and when you are happy with the changes that you have made, please follow these steps to open a pull request:\n\n5.4.1 Initial checks\nRun the below to update and check package documentation:\ndevtools::document()\ndevtools::check_man()\nTest that the examples work:\ndevtools::run_examples()\nTest that the readme and vignettes work and update the results if the output of any function has changed:\ndevtools::build_readme()\ndevtools::build_vignettes()\n\n\n5.4.2 Run tests\nAs you then contribute code, make sure that all the current tests and any you add continue to pass. All package tests can be run together with:\ndevtools::test()\nCode to add new functionality should be accompanied by tests. Code coverage can be checked using:\n# note, you may first have to detach the package\n# detach(\"package:IncidencePrevalence\", unload=TRUE)\ndevtools::test_coverage()\n\n\n5.4.3 Adhere to code style\nPlease adhere to the code style when adding any new code. Do not though restyle any code unrelated to your pull request as this will make code review more difficult.\nlintr::lint_package(linters = lintr::linters_with_defaults(\n  lintr::object_name_linter(styles = \"camelCase\")\n))\n\n\n5.4.4 Run check() before opening a pull request\nBefore opening any pull request please make sure to run:\ndevtools::check() \nPlease make sure that the output is the expected:\n\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\n\nAny error or warning will make your pull request actions fail. Although notes can pass the github action tests we encourage to fix all the notes as this is a requirement to keep the package on cran.\n\n\n5.4.5 Opening the pull request\nOnce you’ve made sure that checks are passing and you are happy with your code additions you can open the pull request. When opening the pull request you must take into account the following:\n\nWrite a meaningful title, titles of pull requests are later used to document the changes done. Make sure that the title of the pull request describes the issue that is fixed, therefore the documentation of the changes will be easier.\nLink the issue that your pull request is closing (we strongly encourage to fix issues one by one and do not include multiple issues in the same pull request). You can link a pull request and an issue using any of the gitub closing words or you can do it manually in the development section (bottom of the right sidebar).\nDescribe any potential issue you want to remark. Help the maintainer review your pull request indicating if there is anything you are not sure about or that you want some feedback on. Don’t hesitate to ask any question if needed.",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "contributing.html#reviewing-pull-requests",
    "href": "contributing.html#reviewing-pull-requests",
    "title": "5  Contributing to a package",
    "section": "5.5 Reviewing pull requests",
    "text": "5.5 Reviewing pull requests\nReviewing pull requests is a very important step that the maintainers have to do. When reviewing a pull request you have to find a good equilibrium between being kind (we want to encourage people to contribute to our packages) and being strict (you -as a maintainer- will be the ultimate responsible for that code; so review it carefully and only accept if you are happy about it and you feel comfortable maintaining that code).",
    "crumbs": [
      "Principles",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Contributing to a package</span>"
    ]
  },
  {
    "objectID": "documenting_functions.html",
    "href": "documenting_functions.html",
    "title": "6  Documenting functions",
    "section": "",
    "text": "6.1 Title\nWe use the roxygen2 package for documenting our functions. Using this package will help us to write the .Rd files in the man directory which is what will be rendered when users call ?my_function or help(\"my_function\") and peruse a package website.\nAbove each exported function we’ll create a roxygen block, with lines starting with #'. The general structure is shown below and we’ll go through each in turn.\nWe want to provide a concise yet informative title for our function. The title should typically be written in sentence case but without any full stop at the end.\nIf we run help(package = \"mypackage\") we can see all the functions and their titles for a package. From this we can quickly see how informative our titles are.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documenting_functions.html#description",
    "href": "documenting_functions.html#description",
    "title": "6  Documenting functions",
    "section": "6.2 Description",
    "text": "6.2 Description\nEvery function should have a desription. This could be a sentence or two for a simple function, or multiple paragraphs for a more complex function. The description should summarise the purpose of the function and explain any internal assumptions or decisions made to implement it.\nWhen writing the description we can use markdown commands, for example to add bullet points, italics, etc. This will often help make longer desriptions more readable.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documenting_functions.html#parameters",
    "href": "documenting_functions.html#parameters",
    "title": "6  Documenting functions",
    "section": "6.3 Parameters",
    "text": "6.3 Parameters\nAfter our description of the function as a whole, we will then describe each of the inputs to the function. In general we should be able to describe an argument in a few sentences. We should use them to tell the user what is allowed as an input and then what the input will be used for.\nIf we’re working on a package where we have multiple arguments with the same argument we can document arguments just once. We can create a helper like below for parameter x.\n\n#' Helper for consistent documentation of `x`.\n#'\n#' @param x \n#'\n#' @name xDoc\n#' @keywords internal\n\nWe can then reuse this documentation across the package by using @inheritParams\n\n#' Title\n#' \n#' @description\n#'\n#' @inheritParams xDoc\n#' @param y \n#'\n#' @returns \n#' @export\n#'\n#' @examples",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documenting_functions.html#returns",
    "href": "documenting_functions.html#returns",
    "title": "6  Documenting functions",
    "section": "6.4 Returns",
    "text": "6.4 Returns\nWe must also document what the function will return. For example, we can tell a user that our function will return a tibble with a certain set of columns. If our function has side-effects then we chould also document these.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documenting_functions.html#export",
    "href": "documenting_functions.html#export",
    "title": "6  Documenting functions",
    "section": "6.5 Export",
    "text": "6.5 Export\nBy including the @export tag our documentation will be generated as an .Rd file and users will see it in the package website, etc. If instead we want to document an internal function then we can replace this with @noRd.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "documenting_functions.html#examples",
    "href": "documenting_functions.html#examples",
    "title": "6  Documenting functions",
    "section": "6.6 Examples",
    "text": "6.6 Examples\nLast but by no means least are a set of examples where we provide R code that shows how the function can be used in practice. These examples are quite possible the most important piece of documentation, as it is many users will look at these before reading any of the above.\nTypically we should try to give a number of informative examples that show users how the function can be used and provides some intuition on the impact of different arguments.",
    "crumbs": [
      "Contributing documentation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documenting functions</span>"
    ]
  },
  {
    "objectID": "unit_testing.html",
    "href": "unit_testing.html",
    "title": "9  Unit testing",
    "section": "",
    "text": "do not rely on mock data",
    "crumbs": [
      "Adding unit tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Unit testing</span>"
    ]
  }
]